'use client';

import React, { useSyncExternalStore, useCallback, useMemo, useEffect } from 'react';
import { flushSync } from 'react-dom';

interface AnalysisEvent {
  type: string;
  sessionId?: string;
  data?: string;
  step?: string;
  timestamp?: string;
  metadata?: Record<string, any>;
}

interface AnalysisState {
  sessionId: string;
  events: AnalysisEvent[];
  currentStep: string;
  isActive: boolean;
  lastUpdate: string;
}

interface UseAnalysisStreamReturn {
  analysisStates: AnalysisState[];
  isConnected: boolean;
  connectionError: string | null;
  clearAnalysis: () => void;
  hasActiveAnalysis: boolean;
  getAnalysisForSession: (sessionId: string) => AnalysisState | null;
}

interface StoreSnapshot {
  analysisStates: AnalysisState[];
  isConnected: boolean;
  connectionError: string | null;
  hasActiveAnalysis: boolean;
}

// Analysis Store class for managing external state
class AnalysisStore {
  private analysisStates: AnalysisState[] = [];
  private isConnected: boolean = false;
  private connectionError: string | null = null;
  private eventSource: EventSource | null = null;
  private listeners: Set<() => void> = new Set();
  private backendUrl: string = '';
  private shouldConnect: boolean = true;
  private updateTimeout: NodeJS.Timeout | null = null;
  
  // Stable snapshot objects to prevent infinite loops
  private currentSnapshot: StoreSnapshot;
  private readonly serverSnapshot: StoreSnapshot = {
    analysisStates: [],
    isConnected: false,
    connectionError: null,
    hasActiveAnalysis: false
  };

  constructor(backendUrl: string, shouldConnect: boolean = true) {
    this.backendUrl = backendUrl;
    this.shouldConnect = shouldConnect;
    
    // Initialize current snapshot
    this.currentSnapshot = {
      analysisStates: this.analysisStates,
      isConnected: this.isConnected,
      connectionError: this.connectionError,
      hasActiveAnalysis: false
    };
    
    // Only connect on client side and if shouldConnect is true
    if (typeof window !== 'undefined' && shouldConnect) {
      this.connect();
    }
  }

  // Subscribe to store changes
  subscribe = (listener: () => void) => {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  };

  // Get current snapshot - only update when state actually changes
  getSnapshot = () => {
    return this.currentSnapshot;
  };

  // Server snapshot for SSR
  getServerSnapshot = () => {
    return this.serverSnapshot;
  };

  // Update snapshot and notify listeners with smooth animation
  private updateSnapshot = (immediate: boolean = false) => {
    const hasActiveAnalysis = this.analysisStates.some(a => a.isActive);
    
    // Only create new snapshot if something actually changed
    const newSnapshot: StoreSnapshot = {
      analysisStates: this.analysisStates,
      isConnected: this.isConnected,
      connectionError: this.connectionError,
      hasActiveAnalysis
    };
    
    // Check if snapshot actually changed
    const changed = (
      this.currentSnapshot.analysisStates !== newSnapshot.analysisStates ||
      this.currentSnapshot.isConnected !== newSnapshot.isConnected ||
      this.currentSnapshot.connectionError !== newSnapshot.connectionError ||
      this.currentSnapshot.hasActiveAnalysis !== newSnapshot.hasActiveAnalysis
    );
    
    if (changed) {
      this.currentSnapshot = newSnapshot;
      
      if (immediate) {
        // Immediate update for critical changes (connection status, errors)
        flushSync(() => {
          this.listeners.forEach(listener => listener());
        });
      } else {
        // Smooth update for analysis changes - avoid flushSync to preserve animations
        this.scheduleUpdate();
      }
    }
  };

  // Schedule a smooth update without flushSync to preserve animations
  private scheduleUpdate = () => {
    // If there's already a pending update, don't schedule another one
    if (this.updateTimeout) {
      return;
    }
    
    this.updateTimeout = setTimeout(() => {
      // Use regular React update instead of flushSync to avoid animation interruption
      this.listeners.forEach(listener => listener());
      this.updateTimeout = null;
    }, 50); // Reduced delay for more responsive updates
  };

  // Clear analysis states
  clearAnalysis = () => {
    this.analysisStates = [];
    this.updateSnapshot();
  };

  // Get analysis for specific session
  getAnalysisForSession = (sessionId: string): AnalysisState | null => {
    return this.analysisStates.find(state => state.sessionId === sessionId) || null;
  };

  // Connect to EventSource
  private connect = () => {
    if (!this.backendUrl) return;

    // Close existing connection
    if (this.eventSource) {
      this.eventSource.close();
    }

    try {
      this.eventSource = new EventSource(`${this.backendUrl}/stream/analysis`);

      this.eventSource.onopen = () => {
        this.isConnected = true;
        this.connectionError = null;
        this.updateSnapshot(true); // Immediate update for connection status
      };

      this.eventSource.onmessage = (event) => {
        try {
          const data: AnalysisEvent = JSON.parse(event.data);
          
          if (data.type === 'analysis_connected' || data.type === 'keepalive') {
            return;
          }

          if (data.sessionId && (data.type === 'analysis_start' || data.type === 'analysis_progress' || 
                                data.type === 'analysis_complete' || data.type === 'analysis_error' || 
                                data.type === 'chart_created')) {
            
            // Find or create analysis state for this session
            let analysisState = this.analysisStates.find(state => state.sessionId === data.sessionId);
            
            if (!analysisState) {
              analysisState = {
                sessionId: data.sessionId,
                events: [],
                currentStep: data.step || 'unknown',
                isActive: true,
                lastUpdate: data.timestamp || new Date().toISOString()
              };
              this.analysisStates = [...this.analysisStates, analysisState];
            } else {
              // Update existing state
              const updatedState = {
                ...analysisState,
                events: [...analysisState.events, data],
                currentStep: data.step || analysisState.currentStep,
                isActive: data.type !== 'analysis_complete' && data.type !== 'analysis_error',
                lastUpdate: data.timestamp || new Date().toISOString()
              };
              
              this.analysisStates = this.analysisStates.map(state => 
                state.sessionId === data.sessionId ? updatedState : state
              );
            }
            
            // Update snapshot and notify listeners
            this.updateSnapshot();
          }
        } catch (error) {
          console.error('Error parsing analysis event:', error);
        }
      };

      this.eventSource.onerror = (error) => {
        console.error('Analysis stream error:', error);
        this.isConnected = false;
        this.connectionError = 'Connection lost';
        this.updateSnapshot(true); // Immediate update for error status
        
        // Attempt to reconnect after delay
        setTimeout(() => {
          this.connect();
        }, 3000);
      };

    } catch (error) {
      console.error('Failed to connect to analysis stream:', error);
      this.connectionError = 'Failed to connect';
      this.updateSnapshot(true); // Immediate update for error status
    }
  };

  // Cleanup
  destroy = () => {
    if (this.eventSource) {
      this.eventSource.close();
    }
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
      this.updateTimeout = null;
    }
    this.listeners.clear();
  };
}

// Global store instance cache with cleanup
const storeCache = new Map<string, AnalysisStore>();
const storeRefCounts = new Map<string, number>();

// Cleanup function to remove unused stores
const cleanupStore = (storeKey: string) => {
  const refCount = storeRefCounts.get(storeKey) || 0;
  if (refCount <= 1) {
    // Last reference, cleanup the store
    const store = storeCache.get(storeKey);
    if (store) {
      store.destroy();
      storeCache.delete(storeKey);
    }
    storeRefCounts.delete(storeKey);
  } else {
    // Decrement reference count
    storeRefCounts.set(storeKey, refCount - 1);
  }
};

export const useAnalysisStream = (backendUrl: string, shouldConnect: boolean = true): UseAnalysisStreamReturn => {
  // Create a unique key that includes shouldConnect to avoid cache conflicts
  const storeKey = `${backendUrl}_${shouldConnect}`;
  
  // Get or create store instance for this backend URL and connection state
  const store = useMemo(() => {
    if (!storeCache.has(storeKey)) {
      storeCache.set(storeKey, new AnalysisStore(backendUrl, shouldConnect));
      storeRefCounts.set(storeKey, 1);
    } else {
      // Increment reference count
      const refCount = storeRefCounts.get(storeKey) || 0;
      storeRefCounts.set(storeKey, refCount + 1);
    }
    return storeCache.get(storeKey)!;
  }, [backendUrl, shouldConnect]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanupStore(storeKey);
    };
  }, [storeKey]);

  // Use React 18's useSyncExternalStore for immediate updates
  const snapshot = useSyncExternalStore(
    store.subscribe,
    store.getSnapshot,
    store.getServerSnapshot
  );

  return {
    analysisStates: snapshot.analysisStates,
    isConnected: snapshot.isConnected,
    connectionError: snapshot.connectionError,
    clearAnalysis: store.clearAnalysis,
    hasActiveAnalysis: snapshot.hasActiveAnalysis,
    getAnalysisForSession: store.getAnalysisForSession
  };
};
